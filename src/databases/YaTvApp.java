package databases;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import org.sqlite.SQLiteConfig;
import externalTools.BCrypt;

/**
 * Command-line application for a set of queries on the YaTv database
 * <p>
 * Name: Alex D'Aloisio, Krishanu Datta, Sangeeta Dhingra, Chris Guo
 */
public class YaTvApp {

  /**
   * Allowed query types
   */
  private static enum QueryTypes {
    RegisterUser,
    SubscribeUser,
    AddShow,
    UpdateApp,
    NewVideo,
    Top10Shows,
    FreeVideos,
    LongVideosThisYear,
    AppRevenueRanked,
    VideoTagsRanked,
    EmailSubscribers,
    RewatchExcitingVideo,
    SubscribeToNewApp,
    CombineWatchedVideos,
    HighestPayingCustomer

  }

  /**
   * Query type and parameter value (null if not appropriate)
   *
   * @author derbinsky
   */
  private static class QueryData {

    final public QueryTypes queryType;
    final public String[] queryParam;

    public QueryData(QueryTypes qn, String... qp) {
      queryType = qn;
      queryParam = qp;
    }

    @Override
    public String toString() {
      return String.format("%s" + ((queryParam == null) ? ("") : (" (%s)")), queryType, queryParam);
    }
  }

  /**
   * Usage statement, then exit
   *
   * @return null (to make other code easier)
   */
  private static QueryData _usage() {
    System.out.printf("Usage: java %s <path to YaTv database> <query #> [parameter value]%n%n",
        YaTvApp.class.getCanonicalName());
    System.out.printf("1) Register a new user [parameter value][parameter value][parameter value]"
        + "[parameter value][parameter value][parameter value]?%n");
    System.out.printf("2) Subscribe a user to an app [parameter value] %n");
    System.out
        .printf("3) Add a show to a userâ€™s â€œMy Listâ€� [parameter value] [parameter value]?%n");
    System.out.printf(
        "4) Update an appâ€™s version on a platform [parameter value] [parameter value] %n");
    System.out.printf(
        "5) Add a new video, which is the latest in a showâ€™s current season [parameter value] [parameter value] %n");
    System.out.printf(
        "6) Produce a ranked list of the top-10 most watched shows, each with the corresponding app%n");
    System.out.printf("7) Find all free videos on a particular platform [parameter value] %n");
    System.out.printf(
        "8) Find all long videos that were released this year and arenâ€™t part of any show %n");
    System.out.printf(
        "9) Produce a ranked list of revenue generated by apps in a country [parameter value] %n");
    System.out.printf("10)Produce a ranked list of watch counts from the top-3 video tags %n");
    System.out.printf("11) We want to send out an email to all users of our app that are subscribed"
        + " to a specific mobile app (parameterized) and have less than 2 shows on their watch list,"
        + " to remind them that there are plenty of great shows on our service! We must get all of"
        + " the first and last names (in one String, we need to send both in the email) and emails"
        + " of the users in the database so we can use them using a template. We will Order by"
        + " fullName alphabetically. We only want to email paid users of that mobile app.[parameter value] %n");
    System.out.printf("12) John Smithson is looking for an exciting video to watch, "
        + "that will get his blood pumping (but not too much)! So he wants to rewatch a video he has already seen. "
        + "Get all of the videos and their duration that have the tags drama and horror that are offered on either one of the two apps he is subscribed to."
        + " He also does not want to rewatch something too long, he will not watch something over 1.5 hours, "
        + "so order it by shortest time first, and then name of the video. [parameter value] [parameter value] %n");
    System.out.printf(
        "13) Sally Doe wants to subscribe to a new app, however she does not want to spend a lot of money "
            + "(She is a cousin of John Smithson and is also not made of money). "
            + "She only really likes watching lengthy nature and animal shows (more than 1 season),"
            + " and she does not want to pay more than 14.99 a month. She also prefers watching shows on her phone."
            + " Get all of the prices, if there is a mobile version of the app, as well as the appName for all apps that fulfill these requirements."
            + " Sort by if there is a mobile version, price, then app name. %n");
    System.out.printf(
        "14) Two friends would like to combine their watched videos to share with each other."
            + " Given any two users, find all the paid videos they have both watched and order alphabetically. [parameter value]  [parameter value] [parameter value] [parameter value] %n");
    System.out
        .printf("15) Display all apps and customers that pay the most for that subscription. %n");
    System.exit(0);
    return null;
  }

  /**
   * Validates command-line arguments
   *
   * @param args command-line arguments
   * @return query data, or null if invalid
   * @throws ClassNotFoundException cannot find JDBC driver
   */
  private static QueryData validateInputs(String[] args) throws ClassNotFoundException {
    // must have at least two arguments
    if (args.length < 2) {
      return _usage();
    }

    // attempt connecting to the database
    // (read-only ensures exists)
    Class.forName("org.sqlite.JDBC");
    final SQLiteConfig config = new SQLiteConfig();
    config.setReadOnly(true);
    try (final Connection connection = DriverManager
        .getConnection("jdbc:sqlite:" + args[0], config.toProperties())) {
    } catch (SQLException e) {
      System.out.println(e.getMessage());
      //System.out.println("Invalid database");
      return _usage();
    }

    // make sure second argument is a valid query number
    // and third is appropriate to query
    try {
      final int queryNum = Integer.valueOf(args[1]);

      if (queryNum == 1) {
        if (args.length != 8) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.RegisterUser, args[2], args[3], args[4], args[5], args[6],
              args[7]);
        }
      } else if (queryNum == 2) {
        if (args.length != 6) {
          return _usage();
        } else {
          Integer.valueOf(args[2]);
          return new QueryData(QueryTypes.SubscribeUser, args[2], args[3], args[4], args[5]);
        }
      } else if (queryNum == 3) {
        if (args.length != 4) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.AddShow, args[2], args[3]);
        }
      } else if (queryNum == 4) {
        if (args.length != 4) {
          return _usage();
        } else {
          Integer.valueOf(args[2]);
          return new QueryData(QueryTypes.UpdateApp, args[2], args[3]);
        }
      } else if (queryNum == 5) {
        if (args.length != 10) {
          return _usage();
        } else {
          Integer.valueOf(args[2]);
          Integer.valueOf(args[3]);
          Integer.valueOf(args[8]);
          Integer.valueOf(args[9]);
          return new QueryData(QueryTypes.NewVideo, args[2], args[3], args[4], args[5], args[6],
              args[7], args[8], args[9]);
        }
      } else if (queryNum == 6) {
        if (args.length != 2) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.Top10Shows);
        }
      } else if (queryNum == 7) {
        if (args.length != 3) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.FreeVideos, args[2]);
        }
      } else if (queryNum == 8) {
        if (args.length != 3) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.LongVideosThisYear, args[2]);
        }
      } else if (queryNum == 9) {
        if (args.length != 3) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.AppRevenueRanked, args[2]);
        }
      } else if (queryNum == 10) {
        if (args.length != 2) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.VideoTagsRanked);
        }
      } else if (queryNum == 11) {
        if (args.length != 3) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.EmailSubscribers, args[2]);
        }
      } else if (queryNum == 12) {
        if (args.length != 4) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.RewatchExcitingVideo, args[2], args[3]);
        }
      } else if (queryNum == 13) {
        if (args.length != 2) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.SubscribeToNewApp);
        }
      } else if (queryNum == 14) {
        if (args.length != 6) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.CombineWatchedVideos, args[2], args[3], args[4], args[5]);
        }
      } else if (queryNum == 15) {
        if (args.length != 2) {
          return _usage();
        } else {
          return new QueryData(QueryTypes.HighestPayingCustomer);
        }
      } else {
        return _usage();
      }

    } catch (NumberFormatException e) {
      return _usage();
    }
  }

  /**
   * Command-line Chinook utility
   *
   * @param args command-line arguments
   * @throws ClassNotFoundException cannot find JDBC driver
   * @throws SQLException           SQL gone bad
   */
  public static void main(String[] args) throws ClassNotFoundException, SQLException {

    // validates the inputs, exits if bad
    final QueryData qd = validateInputs(args);

    // makes a connection to the database
    try (final Connection connection = DriverManager.getConnection("jdbc:sqlite:" + args[0])) {

      // turns foreign keys on
      String sqlPragma = "PRAGMA foreign_keys = ON";
      try (final PreparedStatement stmt = connection.prepareStatement(sqlPragma)) {
        try {
          stmt.execute();
        } catch (Exception e) {
          System.out.print(e.getMessage());
        }
      }
    

      if (qd.queryType == QueryTypes.RegisterUser) {
       
            if (qd.queryType == QueryTypes.RegisterUser) {
              String sql = " INSERT INTO user (userID, email, firstName, lastName, password, Country)";
              sql += " VALUES ( ?, ?, ?, ?, ?, ?)";
              try (final PreparedStatement stmt = connection.prepareStatement(sql)) {
                String password_hashed = BCrypt.hashpw(qd.queryParam[4], BCrypt.gensalt());

                stmt.setString(1, qd.queryParam[0]);
                stmt.setString(2, qd.queryParam[1]);
                stmt.setString(3, qd.queryParam[2]);
                stmt.setString(4, qd.queryParam[3]);
                stmt.setString(5, password_hashed);
                stmt.setString(6, qd.queryParam[5]);

                try {
                  stmt.execute();
                  System.out.printf("%s %s %s ", "Added user", qd.queryParam[0], qd.queryParam[1]);
                  System.out.printf("%s %s ", qd.queryParam[2], qd.queryParam[3]);
                  System.out.printf("%s %s", qd.queryParam[4], qd.queryParam[5]);
                } catch (Exception e) {
                  switch (e.getMessage()) {
                    case "[SQLITE_CONSTRAINT]  Abort due to constraint violation (UNIQUE constraint failed: user.userID)":
                      System.out.print("This UserId already exists!");
                      break;
                    case "[SQLITE_MISMATCH]  Data type mismatch (datatype mismatch)":
                      System.out.print("This is not a valid UserId");
                    default:
                      System.out.print(e.getMessage());

                  }
                }

              }
            }
          } 
    
    else if (qd.queryType == QueryTypes.SubscribeUser) {
            String sql1 = "INSERT INTO userSubscriptions (userID, appName, expiration, cost)";
            sql1 = sql1 + " VALUES(?, ?, ?, ?)";
            try (final PreparedStatement stmt = connection.prepareStatement(sql1)) {
              stmt.setString(1, qd.queryParam[0]);
              stmt.setString(2, qd.queryParam[1]);
              stmt.setString(3, qd.queryParam[2]);
              stmt.setString(4, qd.queryParam[3]);
              try {
                stmt.execute();
                System.out.printf("%s", "Subscribed User: " + qd.queryParam[0] + " to app " + qd.queryParam[1]);
                System.out.printf("%s", " for a total of $" + qd.queryParam[3] + "." + " Subscription ends on " + qd.queryParam[2]);
              } catch (Exception e) {
                String msg = "[SQLITE_CONSTRAINT]  Abort due to constraint violation (UNIQUE constraint failed: userSubscriptions.userID, userSubscriptions.appName)";
                if (msg.equals(e.getMessage())) {
                  System.out.print("This subscription already exists.");
                }
                else {
                  System.out.println(e.getMessage());
                }
              }
            }
          } else if (qd.queryType == QueryTypes.AddShow) {
            String sql2 = "INSERT INTO userListShow(userID,showID) VALUES (?, ?)";
            System.out.println(sql2);
            try (final PreparedStatement stmt = connection.prepareStatement(sql2)) {
              stmt.setString(1, qd.queryParam[0]);
              stmt.setString(2, qd.queryParam[1]);
              try {
                stmt.execute();
                System.out.printf("%s%s",
                    "Added show" + qd.queryParam[1] + " to user " + qd.queryParam[0]);

              } catch (Exception e) {
                String msg = "[SQLITE_CONSTRAINT]  Abort due to constraint violation (UNIQUE constraint failed: userListShow.userID, userListShow.showID)";
                String msg2 = "[SQLITE_CONSTRAINT]  Abort due to constraint violation (FOREIGN KEY constraint failed)";
                if (msg.equals(e.getMessage())) {
                  System.out.print("Show is already in user list");
                } else if (msg2.equals(e.getMessage())) {
                  System.out.print("UserID or ShowID does not exist");
                }
              }

            }
          } else if (qd.queryType == QueryTypes.UpdateApp) {
            String sql3 = "UPDATE PlatformApp SET version = ? WHERE appname = ?";
            try (final PreparedStatement stmt = connection.prepareStatement(sql3)) {
              stmt.setString(1, qd.queryParam[0]);
              stmt.setString(2, qd.queryParam[1]);
              try {
                stmt.execute();
                System.out.printf("%s", "The " + qd.queryParam[1] + " app has been updated to version: "+ qd.queryParam[0]);
              } catch (Exception e) {
                String msg = "[SQLITE_CONSTRAINT]  Abort due to constraint violation (UNIQUE constraint failed: version)";
                if (msg.equals(e.getMessage())) {
                  System.out.print("The version already exists.");
                }
              }
            }
          } else if (qd.queryType == QueryTypes.NewVideo) {
            String sql4 = "INSERT INTO video (videoID, isFree, title, releaseDate,";
            sql4 = sql4 + " description, appName, showID, duration)";
            sql4 = sql4 + " Values ( ?, ?, ?, ?, ?, ?, ?, ?)";
            try (final PreparedStatement stmt = connection.prepareStatement(sql4)) {
              stmt.setString(1, qd.queryParam[0]);
              stmt.setString(2, qd.queryParam[1]);
              stmt.setString(3, qd.queryParam[2]);
              stmt.setString(4, qd.queryParam[3]);
              stmt.setString(5, qd.queryParam[4]);
              stmt.setString(6, qd.queryParam[5]);
              stmt.setString(7, qd.queryParam[6]);
              stmt.setString(8, qd.queryParam[7]);
              try {
                stmt.execute();
                System.out.printf("%s",
                    "New Video Added: " + qd.queryParam[0] + " to show: " + qd.queryParam[6]);
                System.out.printf("%s%n", " on app: " + qd.queryParam[5]);
              } catch (Exception e) {
                String msg = "[SQLITE_CONSTRAINT]  Abort due to constraint violation (FOREIGN KEY constraint failed)";
                String msg2 = "[SQLITE_CONSTRAINT]  Abort due to constraint violation (UNIQUE constraint failed: video.videoID)";
                if (msg.equals(e.getMessage())) {
                  System.out.print("app or show does not exist");
                } else if (msg2.equals(e.getMessage())) {
                  System.out.print("Video ID already exists");
                } else {
                  System.out.print(e.getMessage());
                }

              }
            }

          } else if (qd.queryType == QueryTypes.Top10Shows) {
            String sql5 = "SELECT distinct show.title as showName, app.name as appName";
            sql5 = sql5 + " FROM show INNER JOIN inSeason on inSeason.showID = show.showID ";
            sql5 = sql5 + " INNER JOIN video on video.videoID = inSeason.videoID";
            sql5 = sql5 + " INNER JOIN app on video.appName = app.name";
            sql5 = sql5 + " LEFT JOIN userWatchedVideos on userWatchedVideos.videoID = video.videoID";
            sql5 = sql5 + " GROUP BY video.videoID ORDER BY COUNT(userWatchedVideos.userID) DESC LIMIT 10";
            try (final PreparedStatement stmt = connection.prepareStatement(sql5)) {
              System.out.printf("List of top 10 shows: %n");
              try (final ResultSet res = stmt.executeQuery()) {
                int rank = 1;
                while (res.next()) {
                System.out.printf("%d) %s on %s%n", rank, res.getString("showName"), res.getString("appName"));
                rank += 1;
              }
            }
            }
          } else if (qd.queryType == QueryTypes.FreeVideos) {
            String sql6 = "SELECT DISTINCT video.title as VideoTitle from platform inner join platformApp on ";
            sql6 = sql6 + "platformApp.platformName = platform.platformName inner join app on ";
            sql6 = sql6
                + " platFormApp.appName = app.name INNER JOIN video on app.name = video.appName";
            sql6 = sql6 + " WHERE video.isFree = 1 AND platformApp.appName=?";
            try (final PreparedStatement stmt = connection.prepareStatement(sql6)) {
              stmt.setString(1, qd.queryParam[0]);
              try (final ResultSet res = stmt.executeQuery()) {
                while (res.next()) {
                  System.out.printf("%s%n", res.getString("VideoTitle"));
                }
              } catch (Exception e) {
                System.out.print(e.getMessage());
              }
            }


          } else if (qd.queryType == QueryTypes.LongVideosThisYear) {
            String sql7 = "SELECT video.title as title " +
                "FROM video " +
                "WHERE video.duration > ? AND video.videoID NOT IN (SELECT inSeason.videoID FROM inSeason) AND "
                +
                "CAST(SUBSTR(video.releaseDate, length(video.releaseDate) - 3, length(video.releaseDate)) as INTEGER) = 2020";
            try (final PreparedStatement stmt = connection.prepareStatement(sql7)) {
              stmt.setString(1, qd.queryParam[0]);
              try (final ResultSet res = stmt.executeQuery()) {
                System.out.printf(
                    "The following is a list of movies over %s seconds that were released in 2020 and are not part of any show: %n",
                    qd.queryParam[0]);
                while (res.next()) {
                  System.out.printf("%s %n", res.getString("title"));
                }
              } catch (Exception e) {
                System.out.print(e.getMessage());
              }
            }
          } else if (qd.queryType == QueryTypes.AppRevenueRanked) {
            String sql8 = "SELECT app.name as name, SUM(userSubscriptions.Cost) as cost " +
                "FROM userSubscriptions " +
                "INNER JOIN user on userSubscriptions.userID = (SELECT user.userID FROM user WHERE user.country = ?) "
                +
                "INNER JOIN app on app.name = userSubscriptions.appName " +
                "GROUP BY app.name " +
                "ORDER BY SUM(userSubscriptions.Cost) ";
            try (final PreparedStatement stmt = connection.prepareStatement(sql8)) {
              stmt.setString(1, qd.queryParam[0]);
              System.out.printf("The following is a list of apps in %s ranked by their revenue: %n",
                  qd.queryParam[0]);
              try (final ResultSet res = stmt.executeQuery()) {
                int rank = 1;
                while (res.next()) {
                  System.out.printf("%d) %s (Revenue: %d)%n", rank, res.getString("name"),
                      res.getInt("cost"));
                  rank += 1;
                }
              } catch (Exception e) {
                System.out.print(e.getMessage());
              }
            }
          } else if (qd.queryType == QueryTypes.VideoTagsRanked) {
            String sql9 = "SELECT video.title as title, COUNT(userWatchedVideos.userID) as count " +
                "FROM userWatchedVideos " +
                "INNER JOIN video on userWatchedVideos.videoID = video.videoID " +
                "INNER JOIN tags on tags.videoID = video.videoID " +
                "GROUP BY video.videoID " +
                "HAVING tags.videoTag IN " +
                "(SELECT tags.videoTag " +
                "FROM tags " +
                "GROUP BY tags.videoTag " +
                "ORDER BY COUNT(tags.videoTag) desc " +
                "Limit 3) " +
                "ORDER BY COUNT(userWatchedVideos.userID) DESC ";
            try (final PreparedStatement stmt = connection.prepareStatement(sql9)) {
              System.out.printf("List of watch counts from the top-3 video tags: %n");
              try (final ResultSet res = stmt.executeQuery()) {
                int rank = 1;
                while (res.next()) {
                  System.out.printf("%d) %s (Count: %d)%n", rank, res.getString("title"),
                      res.getInt("count"));
                  rank += 1;
                }
              }
            }

          } else if (qd.queryType == QueryTypes.EmailSubscribers) {
            String sql10 = "SELECT PRINTF('%s %s',user.firstName, user.lastName) as fullName,  " +
                "User.email as email " +
                "FROM user " +
                "INNER JOIN userSubscriptions on userSubscriptions.userID = user.userID " +
                "INNER JOIN app on app.name = userSubscriptions.appName " +
                "INNER JOIN platFormApp on platFormApp.appName = app.name " +
                "INNER JOIN platForm on platForm.platFormName = platFormApp.platFormName " +
                "INNER JOIN userListShow on userListShow.userID = user.userID " +
                "WHERE platForm.isMobile = 1 and app.name = ? and userSubscriptions.userID IS NOT NULL "
                +
                "INTERSECT " +
                "SELECT PRINTF('%s %s',user.firstName, user.lastName) as fullName,  " +
                "User.email as email " +
                "FROM user " +
                "INNER JOIN userSubscriptions on userSubscriptions.userID = user.userID " +
                "INNER JOIN app on app.name = userSubscriptions.appName " +
                "INNER JOIN platFormApp on platFormApp.appName = app.name " +
                "INNER JOIN platForm on platForm.platFormName = platFormApp.platFormName " +
                "INNER JOIN userListShow on userListShow.userID = user.userID " +
                "GROUP BY user.userID " +
                "HAVING COUNT(userListShow.showID) < 3 " +
                "ORDER BY fullName ";
            try (final PreparedStatement stmt = connection.prepareStatement(sql10)) {
              stmt.setString(1, qd.queryParam[0]);
              try (final ResultSet res = stmt.executeQuery()) {
                System.out.printf(
                    "All users that are subscribed to %s and have less than 3 shows on their watch list: %n",
                    qd.queryParam[0]);
                while (res.next()) {
                  System.out.printf("Name: %s Email: %s%n", res.getString("fullName"),
                      res.getString("email"));
                }
              } catch (Exception e) {
                System.out.print(e.getMessage());
              }
            }
          } else if (qd.queryType == QueryTypes.RewatchExcitingVideo) {
            String sql = "SELECT video.title as videoName, " +
                "video.duration as duration " +
                "FROM app\n" +
                "INNER JOIN video on video.appName = app.name " +
                "INNER JOIN tags on video.videoID = tags.videoID " +
                "INNER JOIN userWatchedVideos on userWatchedVideos.userID = (SELECT User.userID FROM user WHERE user.firstName = 'John' and user.lastName = 'Smithson') "
                +
                "WHERE video.appName = ? and duration < 90 * 60 and (tags.videoTag = 'horror' or tags.videoTag = 'drama') "
                +
                "UNION " +
                "SELECT video.title as videoName, " +
                "video.duration as duration " +
                "FROM app " +
                "INNER JOIN video on video.appName = app.name " +
                "INNER JOIN tags on video.videoID = tags.videoID " +
                "INNER JOIN userWatchedVideos on userWatchedVideos.userID = (SELECT User.userID FROM user WHERE user.firstName = 'John' and user.lastName = 'Smithson') "
                +
                "WHERE app.name = ? and duration < 90 * 60 and (tags.videoTag = 'horror' or tags.videoTag = 'drama') "
                +
                "ORDER BY duration, videoName ";
            try (final PreparedStatement stmt = connection.prepareStatement(sql)) {

              stmt.setString(1, qd.queryParam[0]);
              stmt.setString(2, qd.queryParam[1]);

              try (final ResultSet res = stmt.executeQuery()) {
                System.out.print("John Smithson's options are:\n");
                while (res.next()) {
                  // Print result of query
                  System.out.printf("%s%d%s%n",
                      "Video Name: " + res.getString("videoName") + " | Duration: ",
                      res.getInt("duration"), " seconds");
                }
              } catch (Exception e) {
                switch (e.getMessage()) {
                  default:
                    System.out.print(e.getMessage());

                }
              }
            }
          } else if (qd.queryType == QueryTypes.SubscribeToNewApp) {
            String sql = "SELECT app.name as appName, " +
                "PRINTF(\"Cost: $%s\",userSubscriptions.cost) as cost, " +
                "(CASE " +
                "    WHEN platform.isMobile = 1 THEN 'yes' " +
                "    WHEN platform.isMobile = 0 THEN 'no' " +
                "    ELSE 'Anomaly in database, we are unsure' " +
                "END) as isOnMobile " +
                "FROM app " +
                "INNER JOIN userSubscriptions on userSubscriptions.appName = app.name " +
                "INNER JOIN platformApp on platformApp.appName = app.name " +
                "INNER JOIN platform on platform.platformName = platformApp.platformName " +
                "INNER JOIN video on video.appName = app.name " +
                "INNER JOIN tags on tags.videoID = video.videoID " +
                "INNER JOIN inSeason on video.videoID = inSeason.videoID " +
                "INNER JOIN show on show.showID = inSeason.showID " +
                "GROUP BY show.showID " +
                "HAVING COUNT(inSeason.showID > 1) and (tags.videoTag = 'nature' OR tags.videoTag = 'animals') and userSubscriptions.cost <= 15 "
                +
                "ORDER BY isOnMobile, cost, appName ";

            try (final PreparedStatement stmt = connection.prepareStatement(sql)) {

              try (final ResultSet res = stmt.executeQuery()) {
                System.out.print("Sally Doe's options are:\n");

                while (res.next()) {
                  // Print result of query
                  System.out.printf("%s%s%s%n", "Name of App: " + res.getString("appName") + " | ",
                      res.getString("cost"), " | Is on Mobile: " +
                          res.getString("isOnMobile"));
                }
              } catch (Exception e) {
                switch (e.getMessage()) {
                  default:
                    System.out.print(e.getMessage());

                }
              }

            }
          } else if (qd.queryType == QueryTypes.CombineWatchedVideos) {
            String sql13 = "SELECT video.title as videoTitle, tags.videoTag as videoTags\n"
                + "FROM User inner join userListShow on User.userID = userListShow.userID\n"
                + "left join show on userListShow.showID = show.showID\n"
                + "inner join inSeason on inSeason.showID = show.showID\n"
                + "inner join video on video.videoID = inSeason.videoID\n"
                + "inner join tags on tags.videoID = video.videoID\n"
                + "WHERE user.firstName =? AND user.lastName =? \n"
                + "UNION ALL\n"
                + "SELECT video.title as videoTitle, tags.videoTag as videoTags \n"
                + "FROM User inner join userListShow on User.userID = userListShow.userID\n"
                + "left join show on userListShow.showID = show.showID\n"
                + "inner join inSeason on inSeason.showID = show.showID\n"
                + "inner join video on video.videoID = inSeason.videoID\n"
                + "inner join tags on tags.videoID = video.videoID\n"
                + "WHERE user.firstName =? AND user.lastName =? \n"
                + "Order by videoTitle, videoTags;";
            try (final PreparedStatement stmt = connection.prepareStatement(sql13)) {
              stmt.setString(1, qd.queryParam[0]);
              stmt.setString(2, qd.queryParam[1]);
              stmt.setString(3, qd.queryParam[2]);
              stmt.setString(4, qd.queryParam[3]);
              try {
                final ResultSet res = stmt.executeQuery();
                System.out.printf("%s%n%n", "Video Titles " + "     Video Tags");
                while (res.next()) {
                  System.out.printf("%s%n",
                      res.getString("videoTitle") + " " + res.getString("videoTags"));
                }
              } catch (Exception e) {
                System.out.println(e.getMessage());
              }
            }

          } else if (qd.queryType == QueryTypes.HighestPayingCustomer) {
            String sql14 = "SELECT app.name as appName, MAX(Usersubscriptions.cost) as highestPayingCost,";
            sql14 = sql14
                + " user.firstName as firstName, user.lastName as lastName, platform.isMobile as platformMobile";
            sql14 = sql14
                + " FROM user inner join userSubscriptions on usersubscriptions.userID = user.userID";
            sql14 = sql14
                + " inner join app on app.name = usersubscriptions.appName inner join platformApp on app.name = platformApp.appName";
            sql14 =
                sql14 + " inner join platform on platformApp.platformName = platform.platformName";
            sql14 = sql14
                + " GROUP by userSubscriptions.appName ORDER BY MAX(userSubscriptions.cost) desc, appName";
            try (final PreparedStatement stmt = connection.prepareStatement(sql14)) {
              System.out.printf("List of highest paying customers: %n");
              try (final ResultSet res = stmt.executeQuery()) {
                int rank = 1;
                while(res.next()) {
                  if(res.getInt("platformMobile") == 0) { 
                System.out.printf("%d) %s %s on %s Total: $%d. Is app mobile? %s%n", rank, res.getString("firstName"), res.getString("lastName"), 
                    res.getString("appName"), res.getInt("highestPayingCost"), "no" );
                rank += 1;
                  
                }
                  else {
                    System.out.printf("%d) %s %s on %s Total: $%d. Is app mobile? %s%n", rank, res.getString("firstName"), res.getString("lastName"), 
                        res.getString("appName"), res.getInt("highestPayingCost"), "yes" );
                    rank += 1;
                    }
                  }
              
              }
            }
          }
        }
  


      }
    }


